\section{The Offline Algorithm}
The algorithm consists of a preprocessing step followed by the monitoring algorithm.
First, we update the structure of the input formula to enable the local evaluation of some subformulas whose signals belong to the same agent.
This allows preserving the total order among the edges of the corresponding signals.
Then, the monitoring step evaluates the updated subformulas incrementally on the refined input signal.

Let $\varphi$ be an STL formula and $(S,{\hb})$ be a distributed signal of $n$ signals $x_1, \ldots x_n$ over the temporal domain $[0,d)$.

\begin{enumerate}
	\item Preprocessing: Restructuring of the subformulas and the input signal
	\begin{enumerate}[label=\arabic*.]
		\item
		Enumerate the subformulas of $\varphi$ such that each formula has an enumeration number smaller than the numbers of all its subformulas.
		Let $\varphi_1, \ldots, \varphi_m$ be such an enumeration.
		Note that $\varphi_1 = \varphi$.
		
		\item
%		Recall that the propositions $\AP$ of $\varphi$ are functions of the values of $x_1, \ldots, x_n$ at a given time point $t$.
		For each agent $A_i$, let $P_i$ be the set of subformulas of $\varphi$ such that for every $\psi \in P_i$ we have
		(i) $\pi(x) = A_i$ for each signal $x$ that occurs in $\psi$,
		(ii) the temporal operators $\psi$ contains, if any, are untimed, and
		(iii) for each subformula $\psi'$ of $\varphi$ such that $\psi$ is a subformula of $\psi'$, the first two conditions are violated.
		For each $\psi \in P_i$, if $\psi$ is not an atomic proposition, define a fresh signal $y$ such that $\pi(y) = A_i$.
		Let $y_1, \ldots, y_M$ be the fresh signals and let $\mathsf{f} : \{y_1, \ldots, y_M\} \to \{\varphi_1, \ldots, \varphi_m\}$ be function that maps each fresh signal to the corresponding subformula of $\varphi$.
		Then, $y_j(t) = [w,t \models \mathsf{f}(y_j)]_{\mathsf{STL}}$ for all $1 \leq j \leq M$ and $0 \leq t < d$, where $w$ is the trace obtained from $S$ by assuming complete synchrony.
		
%		For each $\psi \in P_i$, if $\psi$ is not an atomic proposition, define a fresh proposition.
%		Let $\AP_{\textit{new}} = \{q_1, \ldots, q_M\}$ be the set of fresh propositions and let $\mathsf{f} : \AP_{\textit{new} }\to \{\varphi_1, \ldots, \varphi_m\}$ be function that maps each fresh proposition to the corresponding subformula of $\varphi$.
		
%		and let $\AP' = \AP_{\textit{new}} \cup \AP$.
%		Let $\mathsf{f} : \AP' \to \{\varphi_0, \ldots, \varphi_m\}$ be function that maps each fresh proposition in $\AP_{\textit{new}}$ to the corresponding subformula and each (nonfresh) proposition of $\varphi$  in $\AP$ to itself.
		
		\item
		For each fresh signal $y_j$, define a fresh proposition $q_j = (y_j > 0)$ and replace in $\varphi$ the subformula $\mathsf{f}(q_j)$ with $q_j$.
%		For each fresh proposition $q_i \in \AP_{\textit{new}}$, replace in $\varphi$ the subformula $\mathsf{f}(q_i)$ with the expression $y_i > 0$ where $y_i$ is the satisfaction signal of the subformula $\mathsf{f}(q_i)$ \alert{with respect to the 2-valued finite-trace semantics of STL}. \rednote{the way it's defined can be taken this way too}
		Let $\varphi'$ be the obtained formula.
		Let $\varphi_1', \ldots, \varphi_{m'}'$ be the subformulas of $\varphi'$ satisfying the enumeration invariant given above.
		Note that $\varphi_1'$  and $\varphi$ are semantically equivalent. %some redundancy to handle here
		
		\item
		We define a new distributed signal appropriately extending $(S,{\hb})$ with the fresh propositions.
		Let $(S', {\hb}')$ be a distributed signal with $S' = (x_1, \ldots, x_n, y_1, \ldots, y_M)$ and ${\hb}'$ the smallest extension of ${\hb}$ from $S$ to $S'$ satisfying \Cref{defn:hb}. 
		%where $y_i$ is the satisfaction signal of the proposition $q_i \in \AP_{\textit{new}}$ for each $1 \leq i \leq L$, 
		
	\end{enumerate}

	\item Monitoring
	\begin{enumerate}[label=\arabic*.]
		\item
		Let $G_{S'} = \{ [t_1, t_2), \ldots, [t_k, t_{k+1}) \}$ be the canonical segmentation of $(S', {\hb}')$.
		
		\item
		For $i = k .. 1$, for $j = m' .. 1$, compute $[S', t_i \models \varphi_j']$.
		
		\item
		Output \TODO: match the semantics -- \alert{$\first([S',0 \models \varphi_1'])$}.
	\end{enumerate}
\end{enumerate}

\begin{example}
	\TODO: demonstrate the preprocessing, describe and give the output of the monitoring? \ege{Is this too much?}
\end{example}

\begin{claim}
	For every distributed signal $(S, {\hb})$ of bounded clock skew $\varepsilon$ and bounded variability $\delta$, the output of the monitoring algorithm contains the set $\{ [w \models \varphi]_3 \st w \in \tr(S, {\hb}) \}$.
\end{claim}
\begin{proof}
	\TODO
\end{proof}

\begin{claim}
	The algorithm runs in time and space linear in the size of the input formula and the number of edges in the input signal. \TODO: check
\end{claim}
\begin{proof}
	\TODO %first bound the length of value expressions using bounded variability
	
	Let $(S {\hb})$ be a distributed signal of $n$ signals.
	Let $\varepsilon$ be the maximum clock skew and $\delta$ the bounded variability constant.
	Let $g$ be the number of edges of the signal.
	
	Computing the canonical segmentation $G_S$ takes $O(g (n + \log g))$ time and $O(g)$ space.
	
	Computing the initial value expressions w.r.t. local uncertainty intervals takes $O(n g)$ time and space.
	
	Computing the initial value expressions $\gamma$ w.r.t. $G_S$ takes $O(n g 2^g)$ time and space.
	%for each signal : for each segment : for each element in the segment's current value expression (for general signals this is exponential in the number of uncertainty intervals containing the segment, linear for alternating bits) : extend the current element in at most 3 ways (length of the value expression is 2, for infix we get 3 elements) =  O(n g 2^g 3)
	% 2^g is potentially too conservative?
	
	Bound on the lengths of boolean value expressions of atomic propositions:
	
	Bound on the size of boolean value expression sets of atomic propositions:
\end{proof}