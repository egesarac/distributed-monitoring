\section{Preliminaries}

We denote by $\B = \{ \bot, \top \}$ the set of boolean truth values, $\R$ the set of reals, $\R_{\geq 0}$ the set of nonnegative reals, $\R_{> 0}$ the set of positive reals.
A closed interval $[a,b] \subseteq \R$ of reals has length $|b-a|$.
%, $\N$ the set of natural numbers (including 0).

\subsection{Signal Model}

\begin{definition}
	A \emph{(boolean) signal} is a right-continuous function $x : I \to \B$ where $I \subseteq \R_{\geq 0}$ is a closed interval of nonnegative reals.
\end{definition}

We consider an asynchronous and loosely-coupled message-passing system of $N \geq 2$ reliable agents, denoted $\A = \{A_1, \ldots, A_N\}$.
The agents produce a set of $n \geq 2$ signals $\S = \{x_1, \ldots, x_n\}$ where $x_i : [0,d] \to \B$ for some $d \in \R_{\geq 0}$. %todo: right-open or right-closed?
The function $\pi : \S \to \A$ maps each signal to the agent it is produced by.
The agents do not share memory or a global clock.
Only to formalize statements, we speak of a hypothetical global clock and denote its value by $T$.
For denoting local time values, we use the lowercase letters $t$ and $s$.

We represent the local clock of the agent $A_i$ as an increasing function $c_i : \R_{\geq 0} \to \R_{\geq 0}$ that maps a global time $T$ to a local time $c_i(T)$ of $A_i$.
We denote by $c_i^{-1}$ the inverse of the local clock function $c_i$.
We assume that the system is \emph{partially synchronous}: the agents use a clock synchronization algorithm that guarantees a bounded clock skew with respect to a fixed reference clock, i.e., $|c_i(T) - \chi(T)| < \varepsilon$ for all $1 \leq i \leq N$ and $T \in \R_{\geq 0}$, where $\chi : \R_{\geq 0} \to \R_{\geq 0}$ is the reference clock and $\varepsilon \in \R_{> 0}$ is the maximum clock skew. %TODO: strict or nonstrict? nonzero or not?

%TODO: check later if necessary
An \emph{event} of a given signal $x_i$ is a pair $(t, x_i(t))$ where $t$ is a local clock value of the agent $\pi(x_i)$.
We denote by $E_i$ the set of events of signal $x_i$.
An \emph{edge} of $x_i$ is an event $(t, x_i(t))$ such that $\lim_{s \to t^-} x_i(s) \neq \lim_{s \to t^+} x_i(s)$.
In particular, it is a \emph{rising} edge if $\lim_{s \to t^-} x_i(s) < \lim_{s \to t^+} x_i(s)$, and a \emph{falling} edge otherwise.
We respectively denote by $D_{x_i}^\uparrow$ and $D_{x_i}^\downarrow$ the sets of rising and falling edges of $x_i$, and we let $D_{x_i} = D_{x_i}^\uparrow \cup D_{x_i}^\downarrow$.
%Moreover, we let $D = \bigcup_{i = 1}^{n} D_{x_i}$ to denote the set of events of a distributed signal $S = (x_1, \ldots, x_n)$ 

We assume that signals have \emph{bounded variability} with respect to the reference clock: for each signal $x_i$ and every pair $(t, x_i(t)), (t', x_i(t')) \in D_i$ of edges, we have $|\chi(c_j^{-1}(t)) - \chi(c_j^{-1}(t'))| \geq \delta$, where $A_j = \pi(x_i)$ is the agent that produces $x_i$ and $\delta \in \R_{\geq 0}$ is the bounded variability constant.

\begin{definition}
	A \emph{distributed signal} is a pair $(S, {\hb})$ where $S = (x_1, \ldots, x_n)$ is a vector of signals and ${\hb}$ is the happened-before relation between events in signals extended with the partial synchrony assumption as follows.
	\begin{itemize}
		\item For every agent, the events of its signal are totally ordered, i.e., for all $1 \leq i \leq n$ and $(t, x_i(t)), (t', x_i(t')) \in E_i$, if $t < t'$ then $(t, x_i(t)) \hb (t', x_i(t'))$.
		\item Every pair of events whose timestamps are more than $\varepsilon$ apart is totally ordered, i.e., for all $1 \leq i,j \leq n$ and events $(t, x_i(t)) \in E_i$ and $(t', x_j(t')) \in E_j$, if $t + \varepsilon < t'$ then $(t, x_i(t)) \hb (t', x_j(t'))$. %TODO: strict or nonstrict?
	\end{itemize}
\end{definition}

\begin{example}
	\TODO: distributed signal, happened-before relation
\end{example}

\begin{definition}
	Let $(S, {\hb})$ be a distributed signal of $n$ signals, and $E = \bigcup_{i = 1}^{n} E_i$ be the set of its events.
	A set $C \subseteq E$ is a \emph{consistent cut} iff for every event in $C$, all events that happened before  it also belong to $C$, i.e., for all $e, e' \in E$, if $e \in C$ and $e' \hb e$, then $e' \in C$.
\end{definition}

We denote by $\CC(T)$ the (infinite) set of consistent cuts at global time $T$.
Given a consistent cut $C$, its \emph{frontier} $\fr(C) \subseteq C$ is the set consisting of the last events in $C$ of each signal, i.e., $\fr(C) = \bigcup_{i = 1}^{n} \{ (t, x_i(t)) \in E_i \cap C \st \forall t' > t : (t', x_i(t')) \notin E_i \cap C \}$.

A \emph{consistent cut flow} is a function $f : I \to 2^E$, where $I \subset \R_{\geq 0}$ is a closed interval, that maps a global clock value $T$ to the frontier of a consistent cut at time $T$, i.e., $f(T) \in \{\fr(C) \st C \in \CC(T)\}$.
Moreover, for all $T,T' \in I$ and $1 \leq i \leq n$, if $T < T'$, then for every pair of events $(c_j(T), x_i(c_j(T))) \in f(T)$ and $(c_j(T'), x_i(c_j(T'))) \in f(T')$ we have $(c_j(T), x_i(c_j(T))) \hb (c_j(T'), x_i(c_j(T')))$, where $A_j = \pi(x_i)$.
We denote by $\CCF(S,{\hb})$ the set of all consistent cut flows of the distributed signal $(S,{\hb})$.

\begin{example}
	\TODO: consistent cut, frontier, consistent cut flow
\end{example}

\subsection{RV-LTL} \label{sec:rvltl}

Let $\AP$ be a set of atomic propositions.
The syntax is given by the following grammar where $p \in \AP$.
$$ \varphi :=  p ~|~ \lnot \varphi ~|~ \varphi \lor \varphi ~|~ \varphi \until \varphi $$
We additionally use the following standard abbreviations: $\true = p \lor \lnot p$, $\false = \lnot \true$, $ \varphi_1 \land \varphi_2 = \lnot \varphi_1 \lor \lnot \varphi_2$, $\LTLf \varphi = \true \until \varphi$, and $\LTLg \varphi = \lnot \LTLf \lnot \varphi$.

%A trace $w = (E_1, \ldots, E_n)$ is a vector of event sets of continuous-time boolean-valued finite-length signals $x_1, \ldots, x_n$ whose initial values are $v_0, \ldots, v_n$.

%TODO: this paragraph is a little handwavy
We assume the reader is familiar with the infinite-trace semantics of LTL, which we denote by $[\omega \models \varphi]$ where $\omega$ is a vector of continuous-time boolean-valued infinite-length signals and $\varphi$ is a formula with the syntax above.

A trace $w = (x_1, \ldots, x_n)$ is a vector of signals $x_i : [0,d] \to \B$, each corresponding to the atomic proposition $p_i \in \AP$.
Let $w$ be a trace and $t \in [0,d]$ a timestamp.
We recall the semantics of FLTL defined over $\B = \{\bot, \top\}$ where $\bot < \top$ and they are complementary to each other. 
\begin{align*}
	[w,t \models p_i]_F &= x_i(t)\\
	[w,t \models \lnot \varphi]_F &= \overline{[w,t \models \varphi]_F}\\
	[w,t \models \varphi_1 \lor \varphi_2]_F &= \max([w,t \models \varphi_1]_F, [w,t \models \varphi_2]_F)\\
	[w,t \models \varphi_1 \until \varphi_2]_F &= \max_{t \leq t' \leq d} \left( \min \left( [w,t' \models \varphi_2]_F, \min_{t \leq t'' \leq t'} \left( [w,t'' \models \varphi_1]_F \right) \right) \right)\\
\end{align*}

Now, let us recall the semantics of LTL3 defined over $\B_3 = \B \cup \{\?\}$ where $\bot < \? < \top$ and $\?$ is complementary to itself. %TODO: concat is not defined
\begin{align*}
	[w,t \models \varphi]_3 &= \begin{cases}
		\top &\text{if for all } \omega : \R_{\geq 0}^n \to \B^n \text{ we have } [w \omega \models \varphi]\\
		\bot &\text{if for all } \omega : \R_{\geq 0}^n \to \B^n \text{ we have } [w \omega \models \lnot \varphi]\\
		\? &\text{otherwise}\\
	\end{cases}
\end{align*}

Finally, the semantics of RV-LTL is defined over $\B_4 = \B \cup \{\bot_c, \top_c \}$ where $\bot < \bot_c < \top_c < \top$ and the values $\bot_c$ and $\top_c$ complement each other.
\begin{align*}
	[w,t \models \varphi]_{RV} &= \begin{cases}
		\top &\text{if } [w,t \models \varphi]_3 = \top \\
		\top_c &\text{if } [w,t \models \varphi]_3 = \? \text{ and } [w,t \models \varphi]_F = \top \\
		\bot_c &\text{if } [w,t \models \varphi]_3 = \? \text{ and } [w,t \models \varphi]_F = \bot \\
		\bot &\text{if } [w,t \models \varphi]_3 = \bot \\
	\end{cases} \\
\end{align*}	

\subsection{Problem Statement}

Let $S = (x_1, \ldots, x_n)$ where $x_i : [0,d] \to \B$ for some $d \in \R_{\geq 0}$.
For a distributed signal $(S,{\hb})$, a consistent cut flow $f \in \CCF(S,{\hb})$ yields a concrete trace $S_f = (x'_1, \ldots x'_n)$ such that $(c_j(T), x_i(c_j(T))) \in f(T)$ implies $\alert{x_i'(T)} = x_i(c_j(T))$ for all $1 \leq i \leq n$ and $T \in [0,d]$, where $A_j = \pi(x_i)$.
\alert{The set of traces of $(S,{\hb})$ is given by $\tr(S,{\hb}) = \{ S_f \st \exists f \in \CCF(S,{\hb})\}$.}

%For a distributed signal $(S,{\hb})$, a sequence $C_0 C_1 \ldots$ of consistent cuts is \emph{valid} iff $C_i \subset C_{i+1}$ and $|C_i| + 1 = |C_{i+1}|$ for all $i \geq 0$.
%We denote by $\CC(S,{\hb})$ the set of all valid sequences of consistent cuts of $(S,{\hb})$.
%The set of traces of $(S,{\hb})$ is given by $\tr(S,{\hb}) = \{ \fr(C_0) \fr(C_1) \ldots \st C_0 C_1 \ldots \in \CC(S,{\hb}) \}$.

Given a distributed signal $(S, {\hb})$, an LTL formula $\varphi$, a bounded variability constant $\delta > 0$, and a maximum clock skew $\varepsilon > 0$, we aim to compute the set $[S, {\hb} \models \varphi] = \{ [w, 0 \models \varphi]_{RV} \st w \in \tr(S, {\hb}) \}$ of truth values.

\begin{example}
	\TODO: precise solution without and with $\varepsilon$ and $\delta$, under-approximations and over-approximations
\end{example}

\section{Our Approach}

%todo?
We assume that the monitor runs on the same process as the reference clock and it knows the values of $\delta$ and $\varepsilon$.

\subsection{Uncertainty Regions and Canonical Segmentations}

Consider a signal $x : [0,d] \to \B$ with $x(0) = \bot$ and a single rising edge at local time $t$.
A monitor observing $x$ from another process/agent needs to take into account the clock skew: according to the reference clock, the rising edge of $x$ occurs in the range $(t - \varepsilon, t + \varepsilon)$.
This range is called an \emph{uncertainty region} because the monitor cannot tell the value of $x$ precisely, but only that it changes from $\bot$ to $\top$.
To systematically reason about uncertainty regions of signals, we define the notion of segmentation of temporal domains of signals.

\begin{definition}
	Given an interval $I \subset \R_{\geq 0}$, a \emph{segmentation} of $I$ is a partition of $I$ into finitely many intervals $I_1, \ldots, I_k$ of the form \alert{$I_j = [t_j, t_{j+1})$} for all $1 \leq j \leq k$.
%	Given a signal $x : I \to \B$, a \emph{segmentation} of $x$ is a partition of its temporal domain $I$ into finitely many intervals $I_1, \ldots, I_k$ of the form \alert{$I_j = [t_j, t_{j+1})$} for all $1 \leq j \leq k$.
	By extension, a segmentation of a collection of signals with the same temporal domain $I$ is a segmentation of $I$.
\end{definition}

Let $x : [0,d] \to \B$ be a signal and $D_x = \{(t_1, x(t_1)), \ldots, (t_m, x(t_m))\}$ be the set of edges of $x$, given in an increasing order of local clock values.
For $1 \leq i \leq m$, let $\theta_{\text{lo}}(x,t_i) = \max\{0, \max_{j \in \{1, i\}} t_j - \varepsilon - (j-i)\delta\}$ and $\theta_{\text{hi}}(x,t_i) = \min\{d, \min_{i \leq j \leq m} t_j + \varepsilon - (j-i)\delta\}$.
Intuitively, $\theta_{\text{lo}}$ and $\theta_{\text{hi}}$ give us the lower and upper bounds on the value of the reference clock for a given edge.
We use these to describe a canonical segmentation of a distributed signal.

Let $(S,{\hb})$ be a distributed signal of $n$ signals.
For each signal $x_i$, let $F_i = \{\theta_{\text{lo}}(x_i, t_j) \st (t_j, x_i(t_j)) \in D_{x_i}\} \cup \{\theta_{\text{hi}}(x_i, t_j) \st (t_j, x_i(t_j)) \in D_{x_i}\}$ be the set of bounds on the reference clock values for its edges.
Let $F = \{0, d\} \cup \bigcup_{i = 1}^{n} F_i$ and let $(a_j)_{1 \leq j \leq |F|}$ be an increasing sequence of clock values corresponding to the elements of $F$.
We define the canonical segmentation of $(S,{\hb})$ as $G_S = \{I_1, \ldots, I_{|F| - 1}\}$ where $I_k = [a_k, a_{k+1})$ for all $1 \leq k \leq |F| - 1$.
Moreover, given $t \in [0,d]$, we define $\theta(S,t) = I'$ where $I' \in G_S$ and $t \in I'$.

\begin{example}
	\TODO: canonical segmentation
\end{example}

%todo: define a function from timestamps to segments.

\subsection{Value Expressions}

Consider a binary alphabet $\Sigma = \{0,1\}$.
We denote by $\Sigma^*$ the set of finite words over $\Sigma$ and by $\epsilon$ the empty word.
Given $u,v \in \Sigma^*$ of the same length, we denote by $u \& v$ the `bitwise and' operation. %todo: formalize

We define the function $\destutter : \Sigma^* \to \Sigma^*$ inductively as follows.
For all $\sigma \in \Sigma \cup \{\epsilon\}$, let $\destutter(\sigma) = \sigma$.
For all $u \in \Sigma^*$ such that $u = \sigma_1 \sigma_2 v$ for some $\sigma_1,\sigma_2 \in \Sigma$ and $v \in \Sigma^*$, let (i) $\destutter(u) = \destutter(\sigma_2 v)$ if $\sigma_1 = \sigma_2$, and (ii) $\destutter(u) = \sigma_1 \cdot \destutter(\sigma_2 v)$ otherwise.
Given a set $L$ of finite words, we define $\destutter(L) = \{\destutter(u) \st u \in L\}$.
Moreover, given an integer $k \geq 0$, we define $\stutter_k : \Sigma^* \to \Sigma^*$ such that $\stutter_k(u) = \{v \in \Sigma^* \st |v| \leq k \land \destutter(v) = \destutter(u)\}$ if $k \geq |u|$, and $\stutter_k(u) = \emptyset$ otherwise. %todo: check the definition

In the sequel, we use finite words from $\destutter(\Sigma^*)$ to denote how the values of a signal evolve through intervals that include uncertainty and interleavings.
We use the following grammar to encode such expressions.

\TODO: add conjunction and negation to syntax and semantics.
$$ \psi := 0 ~|~ 1 ~|~ \psi \cdot \psi ~|~ \psi \triangleleft \psi ~|~ \psi \triangleright \psi ~|~ \psi \diamond \psi $$

An expression generated by the above grammar is a \emph{value expression}.
We denote by $\Psi$ the set of all value expressions.
Letting $\psi_1, \psi_2 \in \Psi$, we inductively define the semantics for our encoding.
\begin{align*}
		\llbracket 0 \rrbracket &=  \{ 0 \} \\
		\llbracket 1 \rrbracket &=  \{ 1 \} \\
		\llbracket \psi_1 \cdot \psi_2 \rrbracket &= \destutter(\{ u_1 \cdot u_2~|~u_1 \in \llbracket \psi_1 \rrbracket \text{ and } u_2 \in \llbracket \psi_2 \rrbracket \}) \\
		\llbracket \psi_1 \triangleleft \psi_2 \rrbracket &= \destutter(\llbracket \psi_1 \rrbracket \; \cup \;  \llbracket \psi_1 \cdot \psi_2 \rrbracket) \\
		\llbracket \psi_1 \triangleright \psi_2 \rrbracket &= \destutter(\llbracket \psi_2 \rrbracket \; \cup \;  \llbracket \psi_1 \cdot \psi_2 \rrbracket) \\
		\llbracket \psi_1 \diamond \psi_2 \rrbracket &= \destutter(\llbracket \psi_1 \triangleleft \psi_2 \rrbracket \; \cup \; \llbracket \psi_1 \triangleright \psi_2 \rrbracket)\\
\end{align*}

%todo: negation = bitwise not of each word, conjunction = destutter of bitwise and of all pairs of words of the same length in stutter_k for k from max len of two words to sum of two lengths

\TODO: clean and match notation, add the explanation of the representation of these and how we do the operations (pref, suff, conj, neg. and others?)





%Let $w = (\psi_1, I_1), (\psi_2, I_2), \ldots , (\psi_n, I_n)$ a continuous-time finite-length boolean signal with uncertainty such that $I_i = [t_i, t_{i+1})$, where $t_1 = 0$ and for all $i \in [0,n)$, $t_{i+1} > t_i$.
%In every interval $I_i$, the signal can assume value patterns defined by the qualitative word $v \in \llbracket \psi_i \rrbracket$.
%
%\begin{example}
%	A signal $w$ of duration $d$ with a single rising edge at time $t$ is represented as $(0, [0, t)), (1, [t, d))$.
%	This same signal, interpreted at some other process, assuming a maximal clock skew $0 < \varepsilon < t$ is represented as $(0, [0, t - \varepsilon)), (0\cdot 1, [t - \varepsilon, t + \varepsilon)), (1, [t + \varepsilon, d))$. %todo: explain the idea (observing from different process etc) at the beginning of the section
%\end{example}
%
%%todo: rephrase, show closure under pfx and sfx, show closure under conjunction
%The first two operations on $\psi$ that we need are its prefix $\pfx(\psi)$ and suffix $\sfx(\psi)$:
%\begin{equation}
%	\begin{array}{lcl}
%		\pfx(\psi) & = & \{ w~|~ \exists w' \text{ s.t. } w\cdot w' \in \llbracket \psi \rrbracket \} \\
%		\sfx(\psi) & = & \{ w~|~ \exists w' \text{ s.t. } w'\cdot w \in \llbracket \psi \rrbracket \} \\
%	\end{array}
%\end{equation}
%
%\begin{example}
%	We need the prefix and the suffix operations when we need to split an interval into two intervals and describe what is allowed in each interval. For example, consider the interval $(0\cdot 1, [t_1, t_2))$ from the previous example and a time $t_1 < t' < t_2$ at which we want to split the interval. We now need to describe what are the qualitative patterns that we can observe in $[t_1, t)$ and in $[t', t_2)$. It is not hard to see that in $[t_1, t')$, we can see either $0$ or $0 \cdot 1$, while in $[t_1, t')$ we can see either $0 \cdot 1$ or $1$. It follows that we can represent $(0 \cdot 1, [t_1, t2)$ as $(\pfx(0\cdot 1), [t_1, t')), (\sfx(0 \cdot 1), [t', t_2))$, where $\pfx(0 \cdot 1) = 0 \triangleleft 1$ and $\sfx(0 \cdot 1) = 0 \triangleright 1$. We want to have simple, syntactic and inductive definition of the prefix and suffix operations.
%\end{example}
%
%%todo: define a function from signals and segments to truth expressions

\subsection{The Logic}
We use the same syntax as in \cref{sec:rvltl}.

%todo: use the above-defined functions to define the semantics
