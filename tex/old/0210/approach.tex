\section{Our Approach}

%todo?
We assume that the monitor runs on the same process as the reference clock and it knows the values of $\delta$ and $\varepsilon$.

\subsection{Uncertainty Regions and Canonical Segmentations}

Consider a signal $x : [0,d) \to \B$ with $x(0) = \bot$ and a single rising edge at local time $t$.
A monitor observing $x$ from another process/agent needs to take into account the clock skew: according to the reference clock, the rising edge of $x$ occurs in the range $(t - \varepsilon, t + \varepsilon)$.
This range is called an \emph{uncertainty region} because the monitor cannot tell the value of $x$ precisely, but only that it changes from $\bot$ to $\top$.
To systematically reason about uncertainty regions of signals, we define the notion of segmentation of temporal domains of signals.


Let $x : [0,d) \to \B$ be a signal and $D_x = \{(t_1, x(t_1)), \ldots, (t_m, x(t_m))\}$ be the set of edges of $x$, given in an increasing order of local clock values.
For $1 \leq i \leq m$, let $\theta_{\text{lo}}(x,t_i) = \max\{0, \max_{j \in \{1, i\}} t_j - \varepsilon - (j-i)\delta\}$ and $\theta_{\text{hi}}(x,t_i) = \min\{d, \min_{i \leq j \leq m} t_j + \varepsilon - (j-i)\delta\}$.
Intuitively, $\theta_{\text{lo}}$ and $\theta_{\text{hi}}$ give us the lower and upper bounds on the value of the reference clock for a given edge.
We use these to describe a canonical segmentation of a distributed signal.

Let $(S,{\hb})$ be a distributed signal of $n$ signals.
For each signal $x_i$, let $F_i = \{\theta_{\text{lo}}(x_i, t_j) \st (t_j, x_i(t_j)) \in D_{x_i}\} \cup \{\theta_{\text{hi}}(x_i, t_j) \st (t_j, x_i(t_j)) \in D_{x_i}\}$ be the set of bounds on the reference clock values for its edges.
Let $F = \{0, d\} \cup \bigcup_{i = 1}^{n} F_i$ and let $(a_j)_{1 \leq j \leq |F|}$ be an increasing sequence of clock values corresponding to the elements of $F$.
We define the canonical segmentation of $(S,{\hb})$ as $G_S = \{I_1, \ldots, I_{|F| - 1}\}$ where $I_k = [a_k, a_{k+1})$ for all $1 \leq k \leq |F| - 1$.
Moreover, given $t \in [0,d)$, we define $\theta(S,t) = I'$ where $I' \in G_S$ and $t \in I'$.

\begin{example}
	\TODO: canonical segmentation
\end{example}

\subsection{Value Expressions}
%We encode possible behaviors of satisfaction signals using sets of alternating bit sequences.

Given $u,v \in \Sigma^*$ of the same length, we respectively denote by $u \BitAnd v$ and $u \BitOr v$ the `bitwise and' and `bitwise or' operations, and by $\BitNeg u$ the `bitwise negation' operation.
In addition, given a nonempty words $u,v \in \Sigma^*$ of length $\ell$, we define as auxiliary bitwise temporal operators as follows:
$$ \mathsf{E} u = \left( \max_{i \leq j \leq \ell - 1} u[j] \right)_{0 \leq i \leq \ell - 1} $$
$$ \mathsf{A} u = \left( \min_{i \leq j \leq \ell - 1} u[j] \right)_{0 \leq i \leq \ell - 1} $$
$$ u \mathsf{U}_0 v = \left( \max_{i \leq j \leq \ell - 1} \left( \min \left( v[j], \min_{i \leq k \leq j - 1} u[k] \right) \right) \right)_{0 \leq i \leq \ell - 1} $$
$$ u \mathsf{U}_1 v = \left( \max \left( u^i \mathsf{U}_0 v^i, \mathsf{A} u^i \right) \right)_{0 \leq i \leq \ell - 1} $$
Observe that $\mathsf{A} u = u \mathsf{U}_1 0^\ell$ and $\mathsf{E} u = 1^\ell \mathsf{U}_0 u$.



Finally, given $u_1, u_2 \in \Sigma^*$, we define $u_1 \otimes u_2 = \{ (v_1,v_2) \st \max(|u_1|, |u_2|) \leq k \leq |u_1| + |u_2|, v_1 \in \stutter_k(u_1), v_2 \in \stutter_k(u_2) \}$ as the asynchronous product of $u_1$ and $u_2$.
By extension, given $L_1, L_2 \subseteq \Sigma^*$, we have $L_1 \otimes L_2 = \{ u_1 \otimes u_2 \st u_1 \in L_1, u_2 \in L_2 \}$.

In the sequel, we use finite words from $\destutter(\Sigma^*)$ to denote how the values of a signal evolve through intervals that include uncertainty and interleavings.
A subset of $\destutter(\Sigma^*)$ is called a \emph{value expression}.
We use the following grammar to encode such expressions. \rednote{add standard set union? add $\pfx$ and $\sfx$?}
$$ \psi := 0 ~|~ 1 ~|~ \lnot \psi ~|~ \psi \sqcap \psi  ~|~ \psi \cdot \psi ~|~ \psi_1 \until_{\!0} \psi_2 ~|~ \psi_1 \until_{\!1} \psi_2 $$  %~|~ \psi \triangleleft \psi ~|~ \psi \triangleright \psi ~|~ \psi \diamond \psi

We denote by $\Psi$ the set of all expressions generated by the above grammar.
Letting $\psi_1, \psi_2 \in \Psi$, we inductively define the semantics for our encoding.
\begin{align*}
		\llbracket 0 \rrbracket &=  \{ 0 \} \\
		\llbracket 1 \rrbracket &=  \{ 1 \} \\
		\llbracket \lnot \psi_1 \rrbracket &= \destutter(\{ \BitNeg u \st u \in \llbracket \psi_1 \rrbracket \}) \\
		\llbracket \psi_1 \sqcap \psi_2 \rrbracket &= \destutter(\{ v_1 \BitAnd v_2 \st (v_1,v_2) \in \llbracket \psi_1 \rrbracket \otimes \llbracket \psi_2 \rrbracket \}) \\
		\llbracket \psi_1 \cdot \psi_2 \rrbracket &= \destutter(\{ u_1 u_2 \st u_1 \in \llbracket \psi_1 \rrbracket, u_2 \in \llbracket \psi_2 \rrbracket \}) \\
		\llbracket \psi_1 \until_{\!0} \psi_2 \rrbracket &= \destutter(\{ v_1 \mathsf{U}_0 v_2  \st (v_1,v_2) \in \llbracket \psi_1 \rrbracket \otimes \llbracket \psi_2 \rrbracket \}) \\
		\llbracket \psi_1 \until_{\!1} \psi_2 \rrbracket &= \destutter(\{ v_1 \mathsf{U}_1 v_2  \st (v_1,v_2) \in \llbracket \psi_1 \rrbracket \otimes \llbracket \psi_2 \rrbracket \}) \\
\end{align*}

\TODO: give intuition for each operation

Note that we can additionally define $\psi_1 \sqcup \psi_2 = \lnot (\lnot \psi_1 \sqcap \lnot \psi_2)$.
Moreover, one can easily verify that $\destutter(\Sigma^*)$ is closed under these operations.

\TODO: explain how we represent the value expressions and how we do the operations (pref, suff, conj, neg. and others?)

%In order to implement these efficiently, we represent subsets of $\destutter(\Sigma^*)$ as follows.
%2D ARRAY STUFF.
%For example, ...
%PREFIX, SUFFIX, NEGATION, AND.






%Let $w = (\psi_1, I_1), (\psi_2, I_2), \ldots , (\psi_n, I_n)$ a continuous-time finite-length boolean signal with uncertainty such that $I_i = [t_i, t_{i+1})$, where $t_1 = 0$ and for all $i \in [0,n)$, $t_{i+1} > t_i$.
%In every interval $I_i$, the signal can assume value patterns defined by the qualitative word $v \in \llbracket \psi_i \rrbracket$.
%
%\begin{example}
%	A signal $w$ of duration $d$ with a single rising edge at time $t$ is represented as $(0, [0, t)), (1, [t, d))$.
%	This same signal, interpreted at some other process, assuming a maximal clock skew $0 < \varepsilon < t$ is represented as $(0, [0, t - \varepsilon)), (0\cdot 1, [t - \varepsilon, t + \varepsilon)), (1, [t + \varepsilon, d))$. %todo: explain the idea (observing from different process etc) at the beginning of the section
%\end{example}
%
%%todo: rephrase, show closure under pfx and sfx, show closure under conjunction
%The first two operations on $\psi$ that we need are its prefix $\pfx(\psi)$ and suffix $\sfx(\psi)$:
%\begin{equation}
%	\begin{array}{lcl}
%		\pfx(\psi) & = & \{ w~|~ \exists w' \text{ s.t. } w\cdot w' \in \llbracket \psi \rrbracket \} \\
%		\sfx(\psi) & = & \{ w~|~ \exists w' \text{ s.t. } w'\cdot w \in \llbracket \psi \rrbracket \} \\
%	\end{array}
%\end{equation}
%
%\begin{example}
%	We need the prefix and the suffix operations when we need to split an interval into two intervals and describe what is allowed in each interval. For example, consider the interval $(0\cdot 1, [t_1, t_2))$ from the previous example and a time $t_1 < t' < t_2$ at which we want to split the interval. We now need to describe what are the qualitative patterns that we can observe in $[t_1, t)$ and in $[t', t_2)$. It is not hard to see that in $[t_1, t')$, we can see either $0$ or $0 \cdot 1$, while in $[t_1, t')$ we can see either $0 \cdot 1$ or $1$. It follows that we can represent $(0 \cdot 1, [t_1, t2)$ as $(\pfx(0\cdot 1), [t_1, t')), (\sfx(0 \cdot 1), [t', t_2))$, where $\pfx(0 \cdot 1) = 0 \triangleleft 1$ and $\sfx(0 \cdot 1) = 0 \triangleright 1$. We want to have simple, syntactic and inductive definition of the prefix and suffix operations.
%\end{example}
%
%%todo: define a function from signals and segments to truth expressions

\subsection{The Overapproximation Logic}
We use the same syntax as in \cref{sec:rvltl}.
Our logic maps each interval in the canonical segmentation to a set of value expressions.
We assume that at any interval the signal can realize any value expression of the interval.
This leads to an overapproximation of the set of possible behaviors as demonstrated below.

\begin{example}
	\TODO: how value expressions overapproximate possible behaviors
\end{example}

Let $(S,{\hb})$ be a distributed signal of $n$ signals $x_1, \ldots x_n$ and let $G_S$ be its canonical segmentation.
We want to compute the value expressions of each signal in every interval in the canonical segmentation.
For this, we first let $\gamma(I, i) = \emptyset$ for all $I \in G_S$ and $1 \leq i \leq n$, and incrementally add value expressions to $\gamma(I, i)$ to capture the potential behaviors of $x_i$ in interval $I$.

For each $x_i$, consider the set $X_i = \cup_{1 \leq j < |D_i|} \{K_{i,j}\}$ of its uncertainty regions, i.e.,  $K_{i,j} = [l_j, h_j)$ where $l_j = \theta_{\text{lo}}(x_i, t_j)$ and $h_j = \theta_{\text{hi}}(x_i, t_j)$.
These intervals have the value expression $01$ if the uncertainty is due to a rising edge or the value expressions $10$ if it is due to a falling edge.
We denote the value expression of interval $K_{i,j}$ by $v_{i,j}$.
Note that for each signal $x_i$ the remaining intervals of the temporal domain $[0,d)$ have the expressions $0$ or $1$.

For each interval $I \in G_S$ where $I = [l,h)$ and each $1 \leq i \leq n$, let $J_i = \{ K_{i,j} \in X_i \st I \subseteq K_{i,j}\}$ be the uncertainty regions of $x_i$ that contain the interval $I$.
For each $K_{i,j} = [l_j, h_j) \in J_i$, do the following:
\begin{itemize}
	\item If $l = l_j$ and $h = h_j$, then add $v_{i,j}$ to $\gamma(I, i)$.
	\item If $l = l_j$ and $h < h_j$, then add $\pfx(v_{i,j})$ to $\gamma(I,i)$.
	\item If $l > l_j$ and $h = h_j$, then add $\sfx(v_{i,j})$ to $\gamma(I,i)$.
	\item If $l > l_j$ and $h < h_j$, then add $\pfx(v_{i,j})$ and $\sfx(v_{i,j})$ to $\gamma(I,i)$.
\end{itemize}
%\begin{itemize}
%	\item If $h < h_j$, then add $\pfx(v_{i,j})$ to $\gamma(I,i)$.
%	\item If $l > l_j$ then add $\sfx(v_{i,j})$ to $\gamma(I,i)$.
%	\item If $l = l_j$ and $h = h_j$, then add $v_{i,j}$ to $\gamma(I, i)$.
%\end{itemize}

Let $\tau : [0,d) \to G_S$ be a function that maps each time stamp to the interval of the canonical segmentation that it belongs to, i.e., $\tau(t) = I$ such that $t \in I$.
We are now ready to define the semantics.
Due to timing uncertainty, the value of a formula depends on the agent from which the signals are observed.
Let $A_j$ be the observing agent and $t$ be a local clock value.
\begin{align*}
	[S,t \models p_i]_{A_j} &= \begin{cases}
		0 &\text{if } i = j \land x_i(t) = \bot \\
		1 &\text{if } i = j \land x_i(t) = \top \\
	 	\gamma(\tau(t), i) &\text{if } i \neq j
	\end{cases} \\
	[S,t \models \lnot \varphi]_{A_j} &= \alert{\lnot} [S,t \models \varphi]_{A_j} \\
	[S,t \models \varphi_1 \land \varphi_2]_{A_j} &= [S,t \models \varphi_1]_{A_j} \sqcap [S,t \models \varphi_2]_{A_j} \\
	[S,t \models \varphi_1 \until \varphi_2]_{A_j} &= \{ \destutter(v_1 \mathsf{U}_{b} v_2) \st (v_1,v_2) \in [S,t \models \varphi_1]_{A_j} \otimes [S,t \models \varphi_2]_{A_j}, \tau(t) = [t',t''),\\ 
	&\hspace{10em} \text{if $t'' < d$, then } b \in \{ u[0] \st u \in [S,t'' \models \varphi_1 \until \varphi_2]_{A_j} \}, \\
	&\hspace{10em} \text{otherwise } b = 0 \} 
\end{align*} \rednote{check the until}


