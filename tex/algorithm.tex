\section{Monitoring Algorithm} \label{sec:algorithm}
\alert{TODO: line numbers, new math env}

In this section, given a distributed signal $(S,{\hb})$, we describe an algorithm to compute $[(S,{\hb}) \models \varphi]_+$.
The algorithm makes use of the function $\gamma$ defined in \cref{sec:approach} without explicitly computing $\tr^+(S,{\hb})$.
To achieve this, we first describe the notion of \emph{asynchronous product} of value expressions to capture potential interleavings within segments.
Then, we show how \emph{bit vectors} can represent asynchronous products and allow us to manipulate them faster.
Finally, we present an algorithm to compute $[(S,{\hb}) \models \varphi]_+$ using operations on bit vectors that encode $\gamma$.

\subsubsection{Asynchronous Product of Value Expressions}
Consider the value expressions $u_1 = 0 \cdot 1$ and $u_2 = 1 \cdot 0$ encoding the behaviors of two signals within a segment.
Due to partial asynchrony, the behaviors within segments can be seen as completely asynchronous.
To capture the potential interleavings of these behaviors, we consider how the values in $u_1$ and $u_2$ can align.
In particular, there are three potential alignments:
(i) the rising edge of $u_1$ happens before the falling edge of $u_2$,
(ii) the falling edge of $u_2$ happens before the rising edge of $u_1$, and
(iii) the two edges happen simultaneously.
We respectively represent these with the tuples $(011, 110)$, $(001, 100)$, and $(01, 10)$ where the first component encodes $u_1$ and the second $u_2$.

Formally, given two value expressions $u_1$ and $u_2$, we define their \emph{asynchronous product} as follows:
\small
$$u_1 \otimes u_2 = \{ \destutter(v_1, v_2) \st v_i \in \stutter_k(u_i), k = |u_1| + |u_2| - 1, i \in \{1,2\} \}$$  
\normalsize
Moreover, given two sets $L_1$ and $L_2$ of value expressions, we write $L_1 \otimes L_2 = \{ u_1 \otimes u_2 \st u_i \in L_i, i \in \{1,2\} \}$.

Asynchronous products of value expressions allow us to lift value expressions to satisfaction signals of formulas.

\begin{example}
	Recall the distributed signal $(S, {\hb})$ in \cref{ex:canonseg} and its $\gamma$ function given in \cref{fig:valexpr}b.
	Suppose we want to compute the value expressions encoding the satisfaction of $x_1 \land x_2$ in the segment $[1,3)$.
	We can achieve this by first computing the asynchronous product $\gamma(x_1, [3,4)) \otimes \gamma(x_2, [3,4))$, and then computing the bitwise conjunction of each pair in the set.
	For example, considering the expression $0 \cdot 1 \cdot 0$ for $x_1$ and $0 \cdot 1$ for $x_2$, the product contains the pair $(010, 011)$.
	Taking the bitwise conjunction of this pair gives us the expression $0 \cdot 1 \cdot 0$ as a potential behavior for the satisfaction of $x_1 \land x_2$ in this segment.
\end{example}

Finally, let us remark the generality of asynchronous products.

\begin{remark}
	Asynchronous products can be extended to value expressions over arbitrary finite alphabets, e.g., to encode real-valued signals.
	This allows us to express more complex properties where atomic propositions can be functions of real-valued signals.
\end{remark}

\subsubsection{Computing the Semantics of STL$^+$}
\TODO

%\SetKwComment{Comment}{/* }{ */}
%\begin{algorithm}
%	\caption{An algorithm with caption}\label{alg:two}
%	\KwData{$n \geq 0$}
%	\KwResult{$y = x^n$}
%	$y \gets 1$\;
%	$X \gets x$\;
%	$N \gets n$\;
%	\While{$N \neq 0$}{
%		\eIf{$N$ is even}{
%			$X \gets X \times X$\;
%			$N \gets \frac{N}{2}$ \Comment*[r]{This is a comment}
%		}{\If{$N$ is odd}{
%				$y \gets y \times X$\;
%				$N \gets N - 1$\;
%			}
%		}
%	}
%\end{algorithm}

\begin{lemma} \label{cl:algo}
	For every distributed signal $(S,{\hb})$, we have $[(S,{\hb}) \models \varphi]_+ = \top$ (resp. $\bot$, ${\,?}$) iff $\alert{...} = \{1\}$ (resp. $\{0\}$, $\{0,1\}$).
%	\begin{itemize}
%		\item $[(S,{\hb}) \models \varphi]_{\mathsf{STL}^+} = \top \iff ... = \{1\}$
%		\item $[(S,{\hb}) \models \varphi]_{\mathsf{STL}^+} = \bot \iff ... = \{0\}$
%		
%		\item $[(S,{\hb}) \models \varphi]_{\mathsf{STL}^+} = {\,?} \iff ... = \{0, 1\}$
%	\end{itemize}
\end{lemma}




\subsubsection{Asynchronous Products as Bit Vectors}
getting to atomic propositions represented as bitvectors
intuition on shortcuts

\begin{remark}
	this method does not generalize to real valued signals
\end{remark}

provide equivalent shortcuts for bitvectors.




