\section{Our Approach}

%todo?
We assume that the monitor runs on the same process as the reference clock and it knows the values of $\delta$ and $\varepsilon$.

\subsection{Uncertainty Regions and Canonical Segmentations}

Consider a signal $x : [0,d) \to \B$ with $x(0) = \bot$ and a single rising edge at local time $t$.
A monitor observing $x$ from another process/agent needs to take into account the clock skew: according to the reference clock, the rising edge of $x$ occurs in the range $(t - \varepsilon, t + \varepsilon)$.
This range is called an \emph{uncertainty region} because the monitor cannot tell the value of $x$ precisely, but only that it changes from $\bot$ to $\top$.
To systematically reason about uncertainty regions of signals, we define the notion of segmentation of temporal domains of signals.

\begin{definition}
	Given an interval $I \subset \R_{\geq 0}$, a \emph{segmentation} of $I$ is a partition of $I$ into finitely many intervals $I_1, \ldots, I_k$ of the form $I_j = [t_j, t_{j+1})$ such that $t_j < t_{j+1}$ for all $1 \leq j \leq k$.
%	Given a signal $x : I \to \B$, a \emph{segmentation} of $x$ is a partition of its temporal domain $I$ into finitely many intervals $I_1, \ldots, I_k$ of the form \alert{$I_j = [t_j, t_{j+1})$} for all $1 \leq j \leq k$.
	By extension, a segmentation of a collection of signals with the same temporal domain $I$ is a segmentation of $I$.
\end{definition}

Let $x : [0,d) \to \B$ be a signal and $D_x = \{(t_1, x(t_1)), \ldots, (t_m, x(t_m))\}$ be the set of edges of $x$, given in an increasing order of local clock values.
For $1 \leq i \leq m$, let $\theta_{\text{lo}}(x,t_i) = \max\{0, \max_{j \in \{1, i\}} t_j - \varepsilon - (j-i)\delta\}$ and $\theta_{\text{hi}}(x,t_i) = \min\{d, \min_{i \leq j \leq m} t_j + \varepsilon - (j-i)\delta\}$.
Intuitively, $\theta_{\text{lo}}$ and $\theta_{\text{hi}}$ give us the lower and upper bounds on the value of the reference clock for a given edge.
We use these to describe a canonical segmentation of a distributed signal.

Let $(S,{\hb})$ be a distributed signal of $n$ signals.
For each signal $x_i$, let $F_i = \{\theta_{\text{lo}}(x_i, t_j) \st (t_j, x_i(t_j)) \in D_{x_i}\} \cup \{\theta_{\text{hi}}(x_i, t_j) \st (t_j, x_i(t_j)) \in D_{x_i}\}$ be the set of bounds on the reference clock values for its edges.
Let $F = \{0, d\} \cup \bigcup_{i = 1}^{n} F_i$ and let $(a_j)_{1 \leq j \leq |F|}$ be an increasing sequence of clock values corresponding to the elements of $F$.
We define the canonical segmentation of $(S,{\hb})$ as $G_S = \{I_1, \ldots, I_{|F| - 1}\}$ where $I_k = [a_k, a_{k+1})$ for all $1 \leq k \leq |F| - 1$.
Moreover, given $t \in [0,d)$, we define $\theta(S,t) = I'$ where $I' \in G_S$ and $t \in I'$.

\begin{example}
	\TODO: canonical segmentation
\end{example}

\subsection{Value Expressions}

Consider a binary alphabet $\Sigma = \{0,1\}$.
We denote by $\Sigma^*$ the set of finite words over $\Sigma$ and by $\epsilon$ the empty word.
Given $u,v \in \Sigma^*$ of the same length, we respectively denote by $u \BitAnd v$ and $u \BitOr v$ the `bitwise and' and `bitwise or' operations, and by $\BitNeg u$ the `bitwise negation' operator.

We define the function $\destutter : \Sigma^* \to \Sigma^*$ inductively as follows.
For all $\sigma \in \Sigma \cup \{\epsilon\}$, let $\destutter(\sigma) = \sigma$.
For all $u \in \Sigma^*$ such that $u = \sigma_1 \sigma_2 v$ for some $\sigma_1,\sigma_2 \in \Sigma$ and $v \in \Sigma^*$, let (i) $\destutter(u) = \destutter(\sigma_2 v)$ if $\sigma_1 = \sigma_2$, and (ii) $\destutter(u) = \sigma_1 \cdot \destutter(\sigma_2 v)$ otherwise.
Given a set $L$ of finite words, we define $\destutter(L) = \{\destutter(u) \st u \in L\}$.
Moreover, given an integer $k \geq 0$, we define $\stutter_k : \Sigma^* \to \Sigma^*$ such that $\stutter_k(u) = \{v \in \Sigma^* \st |v| = k \land \destutter(v) = \destutter(u)\}$ if $k \geq |u|$, and $\stutter_k(u) = \emptyset$ otherwise. %todo: check the definition

In the sequel, we use finite words from $\destutter(\Sigma^*)$ to denote how the values of a signal evolve through intervals that include uncertainty and interleavings.
We use the following grammar to encode such expressions.
$$ \psi := 0 ~|~ 1 ~|~ \lnot \psi ~|~ \psi \land \psi  ~|~ \psi \cdot \psi ~|~ \psi \triangleleft \psi ~|~ \psi \triangleright \psi ~|~ \psi \diamond \psi $$

An expression generated by the above grammar is a \emph{value expression}.
We denote by $\Psi$ the set of all value expressions.
Letting $\psi_1, \psi_2 \in \Psi$, we inductively define the semantics for our encoding.
\begin{align*}
		\llbracket 0 \rrbracket &=  \{ 0 \} \\
		\llbracket 1 \rrbracket &=  \{ 1 \} \\
		\llbracket \lnot \psi_1 \rrbracket &= \destutter(\{ \BitNeg u \st u \in \llbracket \psi_1 \rrbracket \}) \\
		\llbracket \psi_1 \land \psi_2 \rrbracket &= \destutter(\{ v_1 \BitAnd v_2 \st u_1 \in \llbracket \psi_1 \rrbracket, u_2 \in \llbracket \psi_2 \rrbracket, \max(|u_1|, |u_2|) \leq k \leq |u_1| + |u_2|, \\ 
		& \hspace{18em} v_1 \in \stutter_k(u_1), v_2 \in \stutter_k(u_2) \}) \\
		\llbracket \psi_1 \cdot \psi_2 \rrbracket &= \destutter(\{ u_1 \cdot u_2~|~u_1 \in \llbracket \psi_1 \rrbracket, u_2 \in \llbracket \psi_2 \rrbracket \}) \\
		\llbracket \psi_1 \triangleleft \psi_2 \rrbracket &= \destutter(\llbracket \psi_1 \rrbracket \; \cup \;  \llbracket \psi_1 \cdot \psi_2 \rrbracket) \\
		\llbracket \psi_1 \triangleright \psi_2 \rrbracket &= \destutter(\llbracket \psi_2 \rrbracket \; \cup \;  \llbracket \psi_1 \cdot \psi_2 \rrbracket) \\
		\llbracket \psi_1 \diamond \psi_2 \rrbracket &= \destutter(\llbracket \psi_1 \triangleleft \psi_2 \rrbracket \; \cup \; \llbracket \psi_1 \triangleright \psi_2 \rrbracket)\\
\end{align*}

\TODO: give intuition for each operation

Note that we can additionally define $\psi_1 \lor \psi_2 = \lnot (\lnot \psi_1 \land \lnot \psi_2)$.
Moreover, one can easily verify that $\destutter(\Sigma^*)$ is closed under these operations.

\TODO: explain how we represent the value expressions and how we do the operations (pref, suff, conj, neg. and others?)

%In order to implement these efficiently, we represent subsets of $\destutter(\Sigma^*)$ as follows.
%2D ARRAY STUFF.
%For example, ...
%PREFIX, SUFFIX, NEGATION, AND.






%Let $w = (\psi_1, I_1), (\psi_2, I_2), \ldots , (\psi_n, I_n)$ a continuous-time finite-length boolean signal with uncertainty such that $I_i = [t_i, t_{i+1})$, where $t_1 = 0$ and for all $i \in [0,n)$, $t_{i+1} > t_i$.
%In every interval $I_i$, the signal can assume value patterns defined by the qualitative word $v \in \llbracket \psi_i \rrbracket$.
%
%\begin{example}
%	A signal $w$ of duration $d$ with a single rising edge at time $t$ is represented as $(0, [0, t)), (1, [t, d))$.
%	This same signal, interpreted at some other process, assuming a maximal clock skew $0 < \varepsilon < t$ is represented as $(0, [0, t - \varepsilon)), (0\cdot 1, [t - \varepsilon, t + \varepsilon)), (1, [t + \varepsilon, d))$. %todo: explain the idea (observing from different process etc) at the beginning of the section
%\end{example}
%
%%todo: rephrase, show closure under pfx and sfx, show closure under conjunction
%The first two operations on $\psi$ that we need are its prefix $\pfx(\psi)$ and suffix $\sfx(\psi)$:
%\begin{equation}
%	\begin{array}{lcl}
%		\pfx(\psi) & = & \{ w~|~ \exists w' \text{ s.t. } w\cdot w' \in \llbracket \psi \rrbracket \} \\
%		\sfx(\psi) & = & \{ w~|~ \exists w' \text{ s.t. } w'\cdot w \in \llbracket \psi \rrbracket \} \\
%	\end{array}
%\end{equation}
%
%\begin{example}
%	We need the prefix and the suffix operations when we need to split an interval into two intervals and describe what is allowed in each interval. For example, consider the interval $(0\cdot 1, [t_1, t_2))$ from the previous example and a time $t_1 < t' < t_2$ at which we want to split the interval. We now need to describe what are the qualitative patterns that we can observe in $[t_1, t)$ and in $[t', t_2)$. It is not hard to see that in $[t_1, t')$, we can see either $0$ or $0 \cdot 1$, while in $[t_1, t')$ we can see either $0 \cdot 1$ or $1$. It follows that we can represent $(0 \cdot 1, [t_1, t2)$ as $(\pfx(0\cdot 1), [t_1, t')), (\sfx(0 \cdot 1), [t', t_2))$, where $\pfx(0 \cdot 1) = 0 \triangleleft 1$ and $\sfx(0 \cdot 1) = 0 \triangleright 1$. We want to have simple, syntactic and inductive definition of the prefix and suffix operations.
%\end{example}
%
%%todo: define a function from signals and segments to truth expressions

\subsection{The Logic}
We use the same syntax as in \cref{sec:rvltl}.

%todo: use the above-defined functions to define the semantics
